"""YAML binding file generator.

Writes ScannedModule instances as .binding.yaml files compatible with
apcore.BindingLoader.

Adapted from django-apcore's output/yaml_writer.py:
- Changed header comment from "django-apcore" to "flask-apcore"
- Identical _build_binding() and write() logic
- annotations field (serialized from ModuleAnnotations dataclass)
- documentation field (full docstring)
- metadata field (arbitrary key-value data)
"""

from __future__ import annotations

import logging
import re
from dataclasses import asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any

import yaml

if TYPE_CHECKING:
    from flask_apcore.scanners.base import ScannedModule

logger = logging.getLogger("flask_apcore")


class YAMLWriter:
    """Generates .binding.yaml files from ScannedModule instances."""

    def write(
        self,
        modules: list[ScannedModule],
        output_dir: str,
        dry_run: bool = False,
    ) -> list[dict[str, Any]]:
        """Write YAML binding files for each ScannedModule.

        Args:
            modules: List of ScannedModule instances to write.
            output_dir: Directory path to write files to.
            dry_run: If True, return content without writing to disk.

        Returns:
            List of dicts representing the YAML content for each module.
        """
        if not modules:
            return []

        output_path = Path(output_dir).resolve()
        if not dry_run:
            output_path.mkdir(parents=True, exist_ok=True)

        results: list[dict[str, Any]] = []
        timestamp = datetime.now(timezone.utc).isoformat()

        for module in modules:
            binding_data = self._build_binding(module)
            results.append(binding_data)

            if not dry_run:
                # Sanitize module_id for safe filename construction
                safe_id = re.sub(r"[^a-zA-Z0-9._-]", "_", module.module_id)
                # Collapse consecutive dots to prevent path traversal
                safe_id = re.sub(r"\.{2,}", "_", safe_id)
                filename = f"{safe_id}.binding.yaml"
                file_path = (output_path / filename).resolve()

                # Path traversal protection
                if not str(file_path).startswith(str(output_path)):
                    logger.warning(
                        "Skipping file outside output directory: %s",
                        file_path,
                    )
                    continue

                if file_path.exists():
                    logger.warning("Overwriting existing file: %s", file_path)

                header = (
                    f"# Auto-generated by flask-apcore scanner\n"
                    f"# Generated: {timestamp}\n"
                    "# Do not edit manually unless you intend"
                    " to customize schemas.\n\n"
                )
                yaml_content = yaml.dump(binding_data, default_flow_style=False, sort_keys=False)
                file_path.write_text(header + yaml_content, encoding="utf-8")
                logger.debug("Written: %s", file_path)

        return results

    def _build_binding(self, module: ScannedModule) -> dict[str, Any]:
        """Build the YAML-serializable dict for a ScannedModule.

        Includes annotations, documentation, and metadata fields.
        """
        annotations_dict: dict[str, Any] | None = None
        if module.annotations is not None:
            annotations_dict = asdict(module.annotations)

        return {
            "bindings": [
                {
                    "module_id": module.module_id,
                    "target": module.target,
                    "description": module.description,
                    "documentation": module.documentation,
                    "tags": module.tags,
                    "version": module.version,
                    "annotations": annotations_dict,
                    "metadata": module.metadata,
                    "input_schema": module.input_schema,
                    "output_schema": module.output_schema,
                }
            ]
        }
